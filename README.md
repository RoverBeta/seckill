## 高并发秒杀系统

### 流程

- 获取商品列表（redis缓存or查库）-> 
- 查看商品详情（redis缓存or查库）-> 
- 秒杀开启暴露秒杀url -> 
- 提交秒杀请求 -> 
- 后台将用户id和商品id存到redis防止重复提交购买 ->
- 预减库存（ 减redis缓存的库存（若结果小于0，则刷新redis缓存，还是小于0就失败并清除redis上用户id与商品id的信息）） -> 
- 将订单信息（用户id，商品id）存到消息队列中 -> 
- 消息的消费者监听到队列中有消息后，乐观锁减库存（事务，成功即插入订单信息，否则将失败信息存到redis并清除redis上用户id与商品id的信息） -> 
- 前端轮询获取秒杀结果（数据库中有订单数据返回订单号，redis上有失败信息及秒杀失败，否则排队中）

### 防止超卖

- 实现乐观锁，给商品表增加一个version字段。每次更新的时候判断库存>0还有version，一致的话version+1，库存-1；否则失败，再进行重试，超过重试次数秒杀失败。

### 利用缓存

- 抢购开始前，将商品和库存数据同步到redis中，所有的抢购操作都在redis中进行处理，通过Redis预减少库存减少数据库访问
- 获取商品列表和详情页前，先判断redis上是否有缓存，有就直接返回，没有再从数据库中查

### 异步处理

- 利用RabbitMQ实现异步下单，实现流量削峰。一是避免秒杀开启时的高流量导致服务崩溃，二是减少客户端的等待时间。
- 前端轮询返回秒杀的状态。

### 开启时间

- 获取系统后台当前时间，前端将时间与商品开启秒杀时间做比较；
- 秒杀时间到了访问商品url暴露接口，后台再进行时间的判断（防止篡改前台时间），成功返回url后，开启秒杀，提前请求后disable按钮，防止用户重复提交。

### 注册登录

- 注册时将密码跟随机salt值（uuid）进行hash，hash结果跟salt都存进数据库；
- 登录时将密码跟数据库中的salt进行hash，结果跟数据库中的hash结果比较。

### 数据表

- 商品表
- 商品秒杀表
- 订单表
- 订单详情表
- 用户表

